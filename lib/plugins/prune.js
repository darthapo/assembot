// Generated by CoffeeScript 1.6.1
(function() {
  var modParser, path, reqParser, requireParser, resolve_path,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  resolve_path = function(libpath, from) {
    var moduledir;
    if (libpath[0] === '.') {
      moduledir = path.dirname(from);
      if (moduledir === '.' || moduledir === '') {
        moduledir = "";
      } else {
        moduledir = "/" + moduledir;
      }
      return path.resolve("" + moduledir + "/" + libpath).slice(1);
    } else {
      return libpath;
    }
  };

  module.exports = function(assembot, ident) {
    var log;
    ident("Prune", false);
    log = assembot.log;
    assembot.after('scan', function(bot) {
      if (bot.target !== 'js') {
        return;
      }
      if (!((bot.options.main != null) && bot.options.prune)) {
        return;
      }
      log.debug("Building dependency list...");
      return bot.resources.each(function(res) {
        var lib, libs, req, reqs, src, _i, _len, _ref, _results;
        res.dependencies = [];
        if (reqs = res.content.match(requireParser)) {
          log.debug(res.path);
          libs = [];
          _results = [];
          for (_i = 0, _len = reqs.length; _i < _len; _i++) {
            req = reqs[_i];
            if (modParser.test(req)) {
              _ref = modParser.exec(req), src = _ref[0], lib = _ref[1];
              lib = resolve_path(lib, res.path);
              log.debug(" -", lib);
              _results.push(res.dependencies.push(lib));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      });
    });
    return assembot.before('render', function(bot) {
      var add_libs, lib, libs, missing, _i, _j, _len, _len1;
      if (bot.target !== 'js') {
        return;
      }
      if (!((bot.options.main != null) && bot.options.prune)) {
        return;
      }
      log.debug("Building whitelist of modules to include...");
      libs = [];
      missing = [];
      add_libs = function(name) {
        var dep, res, _i, _len, _ref, _results;
        if (__indexOf.call(libs, name) < 0) {
          res = bot.resources.get(name);
          if (res == null) {
            name = "" + name + "/index";
            res = bot.resources.get(name);
          }
          if (res != null) {
            libs.push(name);
            _ref = res.dependencies;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              dep = _ref[_i];
              _results.push(add_libs(dep));
            }
            return _results;
          } else {
            return missing.push(name);
          }
        }
      };
      add_libs(bot.options.main);
      libs.sort();
      for (_i = 0, _len = libs.length; _i < _len; _i++) {
        lib = libs[_i];
        log.debug(" -", lib);
      }
      if (missing.length) {
        log.debug("Missing references:");
        for (_j = 0, _len1 = missing.length; _j < _len1; _j++) {
          lib = missing[_j];
          log.debug(" -", lib);
        }
      }
      return bot.resources.whitelist(libs);
    });
  };

  reqParser = /(require[\s]*?\([\s]*?['"]?[\.a-zA-Z0-9_\-/]*['"]?[\s]*?\))/g;

  modParser = /['"]+([\.a-zA-Z0-9_\-/]*)['"]+/;

  requireParser = /(require[\s\(]+['"]?[\.a-zA-Z0-9_\-\/]*['"]?[\s\)]+)/g;

}).call(this);
