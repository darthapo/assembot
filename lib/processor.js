// Generated by CoffeeScript 1.5.0
(function() {
  var Processor, ProcessorManager, addProcessor, assembot_package, async, build_package, compile_less, compile_stylus, compontent_package, log, manager, notify, packager, path, project_package, project_root, render, replaceTokens, targetOf, tokenParser, transpile, validTarget, _,
    __slice = [].slice;

  _ = require('./util');

  log = require('./log');

  path = require('path');

  async = require('async');

  notify = require('./notify');

  project_root = process.cwd();

  assembot_package = require('../../package');

  project_package = (function() {
    try {
      return require("" + project_root + path.sep + "package");
    } catch (ex) {
      return {};
    }
  })();

  compontent_package = (function() {
    try {
      return require("" + project_root + path.sep + "component");
    } catch (ex) {
      return {};
    }
  })();

  build_package = (function() {
    try {
      return require("" + project_root + path.sep + "build");
    } catch (ex) {
      return {};
    }
  })();

  targetOf = function(filepath) {
    var ext;
    ext = path.extname(filepath);
    return manager.targetForExt(ext);
  };

  validTarget = function(filepath) {
    return targetOf(filepath) !== 'unknown';
  };

  render = function(resources, options, done) {
    var t;
    if (resources.length === 0) {
      log.debug("Rendering 0 resources");
      return done();
    } else {
      log.debug("Rendering " + resources[0].target + " resources:");
    }
    t = function(r, cb) {
      notify.beforeRenderItem(r);
      if (options.replaceTokens) {
        r.content = replaceTokens(r.content, options);
      }
      return transpile(r, options, cb);
    };
    async.each(resources, t, function(err, rest) {
      if (err != null) {
        throw err;
      }
      return done(err);
    });
    return true;
  };

  transpile = function(resource, options, done) {
    return manager.render(resource, options, done);
  };

  tokenParser = /(\{%\-([ a-zA-Z0-9\._]*)\-%\})/g;

  replaceTokens = function(string, context) {
    if (tokenParser.test(string)) {
      return string.replace(tokenParser, function(match, token, value, loc, src) {
        var data, first_part, key, part, parts, _i, _len;
        data = context;
        parts = value.split('.');
        first_part = parts.shift().trim();
        switch (first_part) {
          case 'package':
            data = project_package;
            break;
          case 'assembot':
            data = assembot_package;
            break;
          case 'build':
            data = build_package;
            break;
          case 'component':
            data = component_package;
            break;
          case 'NOW':
            data = new Date();
            break;
          default:
            data = context[first_part];
        }
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          key = part.trim();
          data = data[key];
        }
        return String(data);
      });
    } else {
      return string;
    }
  };

  addProcessor = function(type) {
    return new Processor(type);
  };

  module.exports = {
    targetOf: targetOf,
    validTarget: validTarget,
    render: render,
    transpile: transpile,
    replaceTokens: replaceTokens,
    addProcessor: addProcessor,
    Processor: Processor,
    ProcessorManager: ProcessorManager
  };

  ProcessorManager = (function() {

    function ProcessorManager() {
      this.processors = [];
      this.processorsByType = {};
      this.processorsByExt = {};
      this.extByType = [];
    }

    ProcessorManager.prototype.render = function(resource, options, done) {
      var proc;
      proc = this.processorFor(resource);
      return proc.render(resource, options, done);
    };

    ProcessorManager.prototype.processorFor = function(res) {
      return this.processorsByExt[res.ext];
    };

    ProcessorManager.prototype.targetForExt = function(ext) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this.processorsByExt[ext]) != null ? _ref1.type : void 0) != null ? _ref : 'unknown';
    };

    ProcessorManager.prototype.register = function(processor) {
      var ext, _i, _len, _ref;
      this.processors.push(processor);
      this.processorsByType[processor.type] = processor;
      _ref = processor.extensions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ext = _ref[_i];
        this.processorsByExt[ext] = processor;
      }
      return this;
    };

    ProcessorManager.instance = new ProcessorManager;

    return ProcessorManager;

  })();

  manager = ProcessorManager.instance;

  Processor = (function() {

    function Processor(type) {
      this.type = type;
      this.extensions = [];
      this.requiredLibs = [];
      this.renderQueue = [];
      this.warning = null;
      this.converter = null;
      this.builder = null;
    }

    Processor.prototype.ext = function() {
      var ext, exts, _i, _len;
      exts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = exts.length; _i < _len; _i++) {
        ext = exts[_i];
        if (ext[0] === '.') {
          this.extensions.push(ext);
        } else {
          this.extensions.push("." + ext);
        }
      }
      return this;
    };

    Processor.prototype.requires = function() {
      var reqs;
      reqs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.requiredLibs = reqs;
      return this;
    };

    Processor.prototype.warn = function(msg) {
      this.warning = msg;
      return this;
    };

    Processor.prototype.build = function(builder) {
      var warning;
      this.builder = this.warning != null ? (warning = this.warning, function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        log.info("   NOTE:", warning);
        return builder.apply(null, args);
      }) : builder;
      manager.register(this);
      if (this.requiredLibs.length === 0) {
        this.initialize();
      }
      return this;
    };

    Processor.prototype.initialize = function() {
      var _this = this;
      if (this.loading) {
        return;
      }
      this.loading = true;
      return _.tryRequireAll(this.requiredLibs, function(err, libs) {
        var queued, _i, _len, _ref;
        if (err != null) {
          throw err;
        }
        _this.converter = _this.builder.apply(_this.builder, libs);
        _ref = _this.renderQueue;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          queued = _ref[_i];
          _this.render.apply(_this, queued);
        }
        _this.renderQueue = [];
        return _this.loading = false;
      });
    };

    Processor.prototype.render = function(res, opts, done) {
      var file, o;
      if (this.converter != null) {
        log.debug(" -", res.path);
        o = _.defaults({}, {
          current_file: res
        }, opts);
        try {
          return this.converter(res.content, o, function(err, content) {
            if (err != null) {
              return done(err);
            }
            res.content = content;
            notify.afterRenderItem(res);
            return done(err, res);
          });
        } catch (ex) {
          file = "" + res.path + res.ext;
          ex.name = "Processor Error";
          ex.message = "Processor Error for " + file + ": " + ex.message;
          log.error(ex.message);
          return done(ex, null, opts);
        }
      } else {
        log.trace(" |", res.path, "(queued)");
        this.renderQueue.push([res, opts, done]);
        return this.initialize();
      }
    };

    return Processor;

  })();

  /*
    Default Processors:
  */


  addProcessor('js').ext('.js').build(function() {
    return function(source, opts, converted) {
      return converted(null, source, opts);
    };
  });

  addProcessor('js').ext('.html').build(function() {
    return function(source, opts, converted) {
      return converted(null, "module.exports=" + (JSON.stringify(source)) + ";", opts);
    };
  });

  addProcessor('js').ext('.json').build(function() {
    return function(source, opts, converted) {
      var data;
      data = JSON.parse(source);
      return converted(null, "module.exports=" + (JSON.stringify(data)) + ";", opts);
    };
  });

  addProcessor('js').ext('.coffee', '.litcoffee').requires('coffee-script').build(function(coffee) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.coffee || {}, {
        bare: true
      });
      options.literate = opts.current_file.ext === '.litcoffee' || false;
      output = coffee.compile(source, options);
      return converted(null, output, opts);
    };
  });

  addProcessor('js').ext('.eco').requires('eco').build(function(eco) {
    return function(source, opts, converted) {
      var output;
      output = eco.precompile(source);
      return converted(null, "module.exports= " + output + ";", opts);
    };
  });

  addProcessor('js').ext('.mustache').requires('coffee-templates').build(function(coffeeTmpl) {
    return function(source, opts, converted) {
      var output;
      output = coffeeTmpl.compile(source);
      return converted(null, "module.exports= " + output + ";", opts);
    };
  });

  addProcessor('js').ext('.ejs').requires('ejs').build(function(ejs) {
    return function(source, opts, converted) {
      var output;
      output = ejs.compile(source, {
        client: true,
        compileDebug: false
      });
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addProcessor('js').ext('.dot').requires('doT').build(function(dot) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.dot || opts.doT || {}, {});
      output = dot.compile(source, options);
      return converted(null, "module.exports= " + (output.toString()), opts);
    };
  });

  addProcessor('js').ext('.md', '.markdown').requires('marked').build(function(marked) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.marked || {}, {
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: false,
        smartLists: true
      });
      output = marked(source, options);
      return converted(null, "module.exports=" + (JSON.stringify(output)) + ";", opts);
    };
  });

  addProcessor('js').ext('.jade').requires('jade').warn("Jade requires a runtime, be sure it's included in your page.").build(function(jade) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.jade || {}, {
        client: true,
        compileDebug: false
      });
      output = jade.compile(source, options);
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addProcessor('js').ext('.hogan').requires('hogan.js').warn("Hogan requires a runtime, be sure it's included in your page.").build(function(hogan) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.hogan || {}, {
        asString: 1
      });
      output = hogan.compile(source, options);
      return converted(null, "module.exports= new Hogan.Template(" + (output.toString()) + ");", opts);
    };
  });

  addProcessor('js').ext('.handlebars').requires('handlebars').warn("Handlebars requires a runtime, be sure it's included in your page.").build(function(handlebars) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.handlebars || {}, {
        simple: false,
        commonjs: true
      });
      output = handlebars.precompile(source, options);
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  compile_less = function(less, source, callback) {
    return less.render(source, callback);
  };

  compile_stylus = function(stylus, nib, source, opts, callback) {
    var options;
    options = _.defaults({}, opts.stylus || {}, {
      filename: opts.current_file.filename || 'generated.css',
      paths: opts.load_paths
    });
    return stylus(source).set('filename', opts.current_file.filename || 'generated.css').set('paths', opts.load_paths).set(options).use(nib()).render(callback);
  };

  addProcessor('css').ext('.css').build(function() {
    return function(source, opts, converted) {
      return converted(null, source, opts);
    };
  });

  addProcessor('css').ext('.less').requires('less').build(function(less) {
    return function(source, opts, converted) {
      return compile_less(less, source, function(err, css) {
        if (err != null) {
          converted(err, null, opts);
        }
        return converted(null, css, opts);
      });
    };
  });

  addProcessor('css').ext('.styl').requires('stylus', 'nib').build(function(stylus, nib) {
    var load_paths;
    load_paths = [process.cwd(), path.dirname(__dirname)];
    return function(source, opts, converted) {
      opts.load_paths = load_paths;
      return compile_stylus(stylus, nib, source, opts, function(err, css) {
        if (err != null) {
          return converted(err, null, opts);
        } else {
          return converted(null, css, opts);
        }
      });
    };
  });

  packager = require('./packager');

  addProcessor('js').ext('.ecss').build(function() {
    return function(source, opts, converted) {
      return converted(null, packager.embedded_css(source), opts);
    };
  });

  addProcessor('js').ext('.eless').requires('less').build(function(less) {
    return function(source, opts, converted) {
      return compile_less(less, source, function(err, css) {
        if (err != null) {
          converted(err, null, opts);
        }
        return converted(null, packager.embedded_css(css), opts);
      });
    };
  });

  addProcessor('js').ext('.estyl').requires('stylus', 'nib').build(function(stylus, nib) {
    var load_paths;
    load_paths = [process.cwd(), path.dirname(__dirname)];
    return function(source, opts, converted) {
      opts.load_paths = load_paths;
      return compile_stylus(stylus, nib, source, opts, function(err, css) {
        if (err != null) {
          return converted(err, null, opts);
        } else {
          return converted(null, packager.embedded_css(css), opts);
        }
      });
    };
  });

}).call(this);
