// Generated by CoffeeScript 1.5.0

/*
Assembot! v0.0.1
*/


(function() {
  var api, assemble_files, build_css_package, build_js_package, converter, defaults, fs, inspect, path, pp, print, project_root, puts, uglify, _, _ref;

  path = require('path');

  fs = require('fs');

  _ref = require('util'), puts = _ref.puts, print = _ref.print, inspect = _ref.inspect;

  pp = function(obj) {
    return puts(inspect(obj));
  };

  defaults = require('./defaults');

  _ = require('./util');

  converter = require('./converter');

  project_root = process.cwd();

  uglify = (function() {
    try {
      return converter.tryRequire("uglify-js");
    } catch (ex) {
      return null;
    }
  })();

  module.exports = api = {
    build: function(info, opts) {
      var config, output, src, _results;
      if (opts == null) {
        opts = {};
      }
      puts("ASSEMBOT ACTIVATE!");
      _results = [];
      for (output in info) {
        config = info[output];
        _.extend(config, opts);
        _.defaults(config, defaults.config);
        src = config.source;
        config["package"] = info["package"];
        config.assembot = info.assembot;
        config.options = opts;
        config.projectRoot = project_root;
        if (src != null) {
          config.source = {
            target: src,
            path: path.resolve(src),
            dir: "" + (path.resolve(src)) + path.sep
          };
          config.output = {
            target: output,
            path: path.resolve(output),
            ext: path.extname(output),
            dir: path.dirname(path.resolve(output))
          };
        }
        if (config.output.ext === '.js') {
          print(" - " + config.output.target + "... Assembling... ");
          _results.push(assemble_files('js', config, function(err, js_tree) {
            var output_content;
            output_content = build_js_package(js_tree, config);
            if (!fs.existsSync(config.output.dir)) {
              fs.mkdirSync(config.output.dir);
            }
            if (config.minify) {
              if (uglify != null) {
                print("Minify...");
                output_content = (function() {
                  try {
                    switch (config.minify) {
                      case 1:
                      case 'minify':
                      case 'min':
                        return uglify.minify(output_content, {
                          fromString: true,
                          mangle: false
                        }).code;
                      case 2:
                      case 'mangle':
                      case 'munge':
                      case 'compress':
                        return uglify.minify(output_content, {
                          fromString: true,
                          mangle: true
                        }).code;
                      default:
                        return output_content;
                    }
                  } catch (ex) {
                    print("Error in minify, skipping... ");
                    return output_content;
                  }
                })();
              } else {
                print("(can't minify, install uglify-js)...");
              }
            }
            if (config.header) {
              output_content = "" + (converter.replaceTokens(config.header, config)) + "\n" + output_content;
            }
            fs.writeFileSync(config.output.path, output_content, 'utf8');
            return print("Done!\n");
          }));
        } else if (config.output.ext === '.css') {
          print(" - " + config.output.target + "... Assembling... ");
          _results.push(assemble_files('css', config, function(err, css_tree) {
            var output_content;
            output_content = build_css_package(css_tree, config);
            if (!fs.existsSync(config.output.dir)) {
              fs.mkdirSync(config.output.dir);
            }
            if (config.header) {
              output_content = "" + (converter.replaceTokens(config.header, config)) + "\n" + output_content;
            }
            fs.writeFileSync(config.output.path, output_content, 'utf8');
            return print("Done!\n");
          }));
        } else if (output !== 'package' && output !== 'assembot') {
          puts("Output file extension must either be .js or .css!");
          pp(output);
          _results.push(pp(config));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    server: function(info) {
      return this;
    },
    jsConverter: function(type, converter) {
      converter.addFor('js', type, converter);
      return this;
    },
    cssConverter: function(type, converter) {
      converter.addFor('css', type, converter);
      return this;
    }
  };

  assemble_files = function(type, info, callback) {
    var build_count, ext, file, file_info, fullpath, libpath, output, pkg_list, src_dir, src_path, _i, _len;
    src_path = info.source.path;
    src_dir = "" + src_path + path.sep;
    pkg_list = [];
    output = {};
    _.walkTree(src_path, function(file, fullpath) {
      var ext;
      ext = path.extname(file);
      if (converter.validTypeFor(type, ext)) {
        return pkg_list.push(fullpath);
      }
    });
    build_count = 0;
    for (_i = 0, _len = pkg_list.length; _i < _len; _i++) {
      fullpath = pkg_list[_i];
      file = path.basename(fullpath);
      ext = path.extname(fullpath);
      libpath = fullpath.replace(src_dir, '').replace(ext, '');
      file_info = {
        fullpath: fullpath,
        filename: file,
        loadpath: src_path,
        ext: ext,
        path: libpath
      };
      converter.buildSourceFor(type, fullpath, info, function(err, converted_source) {
        build_count += 1;
        output[file_info.path] = converted_source;
        if (build_count === pkg_list.length) {
          return callback(null, output);
        }
      });
    }
    return pkg_list;
  };

  build_js_package = function(sources, opts) {
    var autoStart, identifier, index, name, result, source, _ref1, _ref2;
    if (opts == null) {
      opts = {};
    }
    identifier = (_ref1 = opts.ident || opts.options.ident) != null ? _ref1 : 'require';
    autoStart = (_ref2 = opts.autoStart || opts.options.autoStart) != null ? _ref2 : false;
    result = "(function(/*! Stitched by Assembot !*/) {\n  if (!this." + identifier + ") {\n    var modules = {}, cache = {}, require = function(name, root) {\n      var path = expand(root, name), module = cache[path], fn;\n      if (module) {\n        return module.exports;\n      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {\n        module = {id: path, exports: {}};\n        try {\n          cache[path] = module;\n          fn(module.exports, function(name) {\n            return require(name, dirname(path));\n          }, module);\n          return module.exports;\n        } catch (err) {\n          delete cache[path];\n          throw err;\n        }\n      } else {\n        throw 'module \\'' + name + '\\' not found';\n      }\n    }, expand = function(root, name) {\n      var results = [], parts, part;\n      if (/^\\.\\.?(\\/|$)/.test(name)) {\n        parts = [root, name].join('/').split('/');\n      } else {\n        parts = name.split('/');\n      }\n      for (var i = 0, length = parts.length; i < length; i++) {\n        part = parts[i];\n        if (part == '..') {\n          results.pop();\n        } else if (part != '.' && part != '') {\n          results.push(part);\n        }\n      }\n      return results.join('/');\n    }, dirname = function(path) {\n      return path.split('/').slice(0, -1).join('/');\n    };\n    this." + identifier + " = function(name) {\n      return require(name, '');\n    }\n    this." + identifier + ".define = function(bundle) {\n      for (var key in bundle)\n        modules[key] = bundle[key];\n    };\n    this." + identifier + ".modules= function() {\n      var names= [];\n      for( var name in modules)\n        names.push(name);\n      return names;\n    }\n  }\n  return this." + identifier + ".define;\n}).call(this)({";
    index = 0;
    for (name in sources) {
      source = sources[name];
      result += index++ === 0 ? "" : ", ";
      result += JSON.stringify(name);
      result += ": function(exports, require, module) {" + source + "}";
    }
    result += "});\n";
    if (autoStart) {
      result += "this." + identifier + "('" + autoStart + "');\n";
    }
    return result;
  };

  build_css_package = function(sources, opts) {
    var content, key, results;
    if (opts == null) {
      opts = {};
    }
    results = "";
    for (key in sources) {
      content = sources[key];
      results += "/* " + key + " */\n";
      results += content;
      results += "\n\n";
    }
    return results;
  };

}).call(this);
