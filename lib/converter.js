// Generated by CoffeeScript 1.5.0
(function() {
  var addConvertor, addConvertorOLD, addCssConvertor, addJsConvertor, api, assembot_package, fs, path, project_package, project_root, type_db, validType, _;

  path = require('path');

  fs = require('fs');

  _ = require('./util');

  project_root = process.cwd();

  assembot_package = require('../package');

  project_package = (function() {
    try {
      return require("" + project_root + path.sep + "package");
    } catch (ex) {
      return {};
    }
  })();

  type_db = {
    ".js": {
      types: [],
      handlers: {}
    },
    ".css": {
      types: [],
      handlers: {}
    }
  };

  validType = function(target) {
    if (target[0] === '.') {
      return target;
    } else {
      return "." + target;
    }
  };

  module.exports = api = {
    debug: function() {
      return _.pp(type_db);
    },
    addFor: function(target, type, converter) {
      target = validType(target);
      type = validType(type);
      type_db[target].types.push(type);
      type_db[target].handlers[type] = converter;
      return this;
    },
    validTypeFor: function(target, ext) {
      var type;
      target = validType(target);
      type = validType(ext);
      if (type_db[target] != null) {
        return type_db[target].types.indexOf(type) >= 0;
      } else {
        return false;
      }
    },
    buildSourceFor: function(target, fullpath, info, callback) {
      var converter, ext, source;
      target = validType(target);
      ext = path.extname(fullpath);
      source = fs.readFileSync(fullpath, 'utf8');
      converter = type_db[target].handlers[ext];
      converter(this.replaceTokens(String(source), info), info, callback);
      return this;
    },
    tokenParser: /(\{%\-([ a-zA-Z0-9\._]*)\-%\})/g,
    replaceTokens: function(string, info) {
      if (info.replaceTokens && this.tokenParser.test(string)) {
        return string.replace(this.tokenParser, function(match, token, value, loc, src) {
          var data, first_part, key, part, parts, _i, _len;
          data = info;
          parts = value.split('.');
          first_part = parts.shift().trim();
          switch (first_part) {
            case 'package':
              data = project_package;
              break;
            case 'assembot':
              data = assembot_package;
              break;
            case 'NOW':
              data = new Date();
              break;
            default:
              data = info[first_part];
          }
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            key = part.trim();
            data = data[key];
          }
          return String(data);
        });
      } else {
        return string;
      }
    }
  };

  addConvertorOLD = function(target, type, modules, handler) {
    var args, converter;
    if (!_.isArray(modules)) {
      modules = [modules];
    }
    args = [];
    if (modules.length > 0) {
      api.addFor(target, type, function(source, opts, callback) {
        var module, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = modules.length; _i < _len; _i++) {
          module = modules[_i];
          _results.push(_.tryRequire(module, function(err, lib) {
            var converter, file, subHandler;
            if (err != null) {
              file = "" + opts.current_file.path + opts.current_file.ext;
              _.pp(err);
              throw "Cannot transpile " + file + ": Module(s) '" + (modules.join("'")) + "' cannot be loaded! " + err;
            }
            args.push(lib);
            if (args.length >= modules.length) {
              converter = handler.apply(handler, args);
              subHandler = function(s, o, c) {
                try {
                  return converter(s, o, c);
                } catch (ex) {
                  file = "" + o.current_file.path + o.current_file.ext;
                  return c(new Error("Transpiler error for " + file + ": " + ex.message), null, o);
                }
              };
              api.addFor(target, type, subHandler);
              return subHandler(source, opts, callback);
            }
          }));
        }
        return _results;
      });
    } else {
      converter = handler.apply(handler, args);
      api.addFor(target, type, function(s, o, c) {
        var file;
        try {
          return converter(s, o, c);
        } catch (ex) {
          file = "" + o.current_file.path + o.current_file.ext;
          return c(new Error("Transpiler error for " + file + ": " + ex.message), null, o);
        }
      });
    }
    return true;
  };

  addConvertor = function(target, type, modules, handler) {
    var loading, queue;
    if (!_.isArray(modules)) {
      modules = [modules];
    }
    loading = false;
    queue = [];
    return api.addFor(target, type, function(origSrc, origOpts, origCallback) {
      queue.push([origSrc, origOpts, origCallback]);
      if (!loading) {
        loading = true;
        return _.tryRequireAll(modules, function(err, libs) {
          var arglist, converter, safeHandler, _i, _len, _results;
          if (err != null) {
            throw "Module(s) '" + (modules.join("'")) + "' cannot be loaded! " + err;
          }
          converter = handler.apply(handler, libs);
          safeHandler = function(src, opts, callback) {
            var file;
            try {
              return converter(src, opts, callback);
            } catch (ex) {
              file = "" + opts.current_file.path + opts.current_file.ext;
              return c(new Error("Transpiler error for " + file + ": " + ex.message), null, opts);
            }
          };
          api.addFor(target, type, safeHandler);
          _results = [];
          for (_i = 0, _len = queue.length; _i < _len; _i++) {
            arglist = queue[_i];
            _results.push(safeHandler.apply(safeHandler, arglist));
          }
          return _results;
        });
      }
    });
  };

  addJsConvertor = function(type, modules, handler) {
    var thisType, _i, _len;
    if (_.isArray(type)) {
      for (_i = 0, _len = type.length; _i < _len; _i++) {
        thisType = type[_i];
        addConvertor('js', thisType, modules, handler);
      }
    } else {
      addConvertor('js', type, modules, handler);
    }
    return true;
  };

  addCssConvertor = function(type, modules, handler) {
    return addConvertor('css', type, modules, handler);
  };

  addJsConvertor('.js', [], function() {
    return function(source, opts, converted) {
      return converted(null, source, opts);
    };
  });

  addJsConvertor('.html', [], function() {
    return function(source, opts, converted) {
      return converted(null, "module.exports=" + (JSON.stringify(source)) + ";", opts);
    };
  });

  addJsConvertor('.json', [], function() {
    return function(source, opts, converted) {
      var data;
      data = JSON.parse(source);
      return converted(null, "module.exports=" + (JSON.stringify(data)) + ";", opts);
    };
  });

  addJsConvertor(['.coffee', '.litcoffee'], 'coffee-script', function(coffee) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.coffee || {}, {
        bare: true
      });
      options.literate = opts.current_file.ext === '.litcoffee' || false;
      output = coffee.compile(source, options);
      return converted(null, output, opts);
    };
  });

  addJsConvertor('.eco', 'eco', function(eco) {
    return function(source, opts, converted) {
      var output;
      output = eco.precompile(source);
      return converted(null, "module.exports= " + output + ";", opts);
    };
  });

  addJsConvertor('.ejs', 'ejs', function(ejs) {
    return function(source, opts, converted) {
      var output;
      output = ejs.compile(source, {
        client: true,
        compileDebug: false
      });
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addJsConvertor('.handlebars', 'handlebars', function(handlebars) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.handlebars || {}, {
        simple: false,
        commonjs: true
      });
      output = handlebars.precompile(source, options);
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addJsConvertor('.jade', 'jade', function(jade) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.jade || {}, {
        client: true,
        compileDebug: false
      });
      output = jade.compile(source, options);
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addJsConvertor('.hogan', 'hogan.js', function(hogan) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.hogan || {}, {
        asString: 1
      });
      output = hogan.compile(source, options);
      return converted(null, "module.exports= new Hogan.Template(" + (output.toString()) + ");", opts);
    };
  });

  addJsConvertor('.dot', 'doT', function(dot) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.dot || opts.doT || {}, {});
      output = dot.compile(source, options);
      return converted(null, "module.exports= " + (output.toString()), opts);
    };
  });

  addJsConvertor(['.md', 'markdown'], 'marked', function(marked) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.marked || {}, {
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: false,
        smartLists: true
      });
      output = marked(source, options);
      return converted(null, "module.exports=" + (JSON.stringify(output)) + ";", opts);
    };
  });

  addCssConvertor('.css', [], function() {
    return function(source, opts, converted) {
      return converted(null, source, opts);
    };
  });

  addCssConvertor('.less', 'less', function(less) {
    return function(source, opts, converted) {
      return less.render(source, function(err, css) {
        if (err != null) {
          converted(err, null, opts);
        }
        return converted(null, css, opts);
      });
    };
  });

  addCssConvertor('.styl', ['stylus', 'nib'], function(stylus, nib) {
    var load_paths;
    load_paths = [process.cwd(), path.dirname(__dirname)];
    return function(source, opts, converted) {
      var options;
      options = _.defaults({}, opts.marked || {}, {
        filename: opts.current_file.filename || 'generated.css',
        paths: load_paths
      });
      return stylus(source).set('filename', opts.current_file.filename || 'generated.css').set('paths', load_paths).set(options).use(nib()).render(function(err, css) {
        if (err != null) {
          return converted(err, null, opts);
        } else {
          return converted(null, css, opts);
        }
      });
    };
  });

}).call(this);
