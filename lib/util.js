// Generated by CoffeeScript 1.5.0
(function() {
  var exec, fs, loaded_libs, loading_now, localRequire, path, spawn, util, walk, _;

  util = require('util');

  fs = require('fs');

  path = require('path');

  spawn = require('child_process').spawn;

  exec = require('child_process').exec;

  exports.pp = function(obj) {
    return util.puts(util.inspect(obj));
  };

  exports.extend = function(obj) {
    var key, source, value, _i, _len, _ref;
    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          obj[key] = value;
        }
      }
    }
    return obj;
  };

  exports.defaults = function(obj) {
    var key, source, value, _i, _len, _ref;
    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          if (obj[key] == null) {
            obj[key] = value;
          }
        }
      }
    }
    return obj;
  };

  exports.walkTree = walk = function(dir, callback, files_only) {
    var file_list, filename, fullpath, stat, _i, _len;
    if (files_only == null) {
      files_only = true;
    }
    file_list = fs.readdirSync(dir);
    for (_i = 0, _len = file_list.length; _i < _len; _i++) {
      filename = file_list[_i];
      fullpath = [dir, filename].join(path.sep);
      stat = fs.statSync(fullpath);
      if (stat.isDirectory()) {
        if (!files_only) {
          callback(filename, fullpath, true);
        }
        walk(fullpath, callback);
      } else {
        callback(filename, fullpath, false);
      }
    }
    return file_list;
  };

  exports.tryRequire = function(name, callback) {
    var lib;
    if (name === null || name === '') {
      callback(null, {});
      return;
    }
    if (loaded_libs[name] != null) {
      callback(null, loaded_libs[name]);
      return;
    }
    try {
      lib = require(name);
      loaded_libs[name] = lib;
      return callback(null, lib);
    } catch (ex) {
      return localRequire(name, callback);
    }
  };

  exports.tryRequireAll = function(names, callback) {
    var libnames, libs, loader, nextLib;
    if (names.length === 0) {
      callback(null, []);
      return;
    }
    libs = [];
    libnames = names.slice();
    nextLib = libnames.shift();
    loader = function(err, lib) {
      if (err != null) {
        return callback(err, null);
      } else {
        libs.push(lib);
        if (libnames.length === 0) {
          return callback(null, libs);
        } else {
          nextLib = libnames.shift();
          return exports.tryRequire(nextLib, loader);
        }
      }
    };
    return exports.tryRequire(nextLib, loader);
  };

  _ = exports;

  loaded_libs = {};

  loading_now = {};

  localRequire = function(name, callback) {
    var child, cmd;
    if (loaded_libs[name] != null) {
      callback(null, loaded_libs[name]);
      return;
    }
    if (loading_now[name] != null) {
      loading_now[name].push(callback);
      return;
    } else {
      loading_now[name] = [];
      loading_now[name].push(callback);
    }
    cmd = "" + process.execPath + " -p -e \"require.resolve('" + name + "')\"";
    child = exec(cmd, function(stdin, stdout, stderr) {
      var cb, err, lib, libpath, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      libpath = stdout.trim();
      if (libpath === '') {
        err = new Error("Could not load '" + name + "' module. (no local path)");
        _ref = loading_now[name];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cb = _ref[_i];
          cb(err, null);
        }
        delete loading_now[name];
      }
      try {
        lib = require(libpath);
        loaded_libs[name] = lib;
        _ref1 = loading_now[name];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          cb = _ref1[_j];
          cb(null, lib);
        }
        return delete loading_now[name];
      } catch (ex) {
        _ref2 = loading_now[name];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          cb = _ref2[_k];
          cb(ex, null);
        }
        return delete loading_now[name];
      }
    });
    return true;
  };

  exports.extend(exports, util);

}).call(this);
