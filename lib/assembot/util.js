// Generated by CoffeeScript 1.6.1
(function() {
  var defaults, exec, extend, fs, isAlreadyLoaded, loaded_libs, loading_now, localRequire, path, pp, spawn, tryRequire, tryRequireAll, util, validateOptionsCallback, walk, walkSync, _ref;

  util = require('util');

  fs = require('fs');

  path = require('path');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  pp = function(obj) {
    return util.puts(util.inspect(obj));
  };

  extend = function(obj) {
    var key, source, value, _i, _len, _ref1;
    _ref1 = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      source = _ref1[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          obj[key] = value;
        }
      }
    }
    return obj;
  };

  defaults = function(obj) {
    var key, source, value, _i, _len, _ref1;
    _ref1 = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      source = _ref1[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          if (obj[key] == null) {
            obj[key] = value;
          }
        }
      }
    }
    return obj;
  };

  walk = function(dir, done) {
    var results;
    results = [];
    return fs.readdir(dir, function(err, list) {
      var pending;
      if (err != null) {
        return done(err);
      }
      pending = list.length;
      if (!pending) {
        return done(null, results);
      }
      list.forEach(function(file) {
        var filepath;
        filepath = "" + dir + path.sep + file;
        return fs.stat(filepath, function(err, stat) {
          if (stat.isDirectory()) {
            return walk(filepath, function(err, res) {
              results = results.concat(res);
              if (!--pending) {
                return done(null, results);
              }
            });
          } else {
            results.push(filepath);
            if (!--pending) {
              return done(null, results);
            }
          }
        });
      });
      return null;
    });
  };

  walkSync = function(dir, callback, files_only) {
    var file_list, filename, fullpath, stat, _i, _len;
    if (files_only == null) {
      files_only = true;
    }
    file_list = fs.readdirSync(dir);
    for (_i = 0, _len = file_list.length; _i < _len; _i++) {
      filename = file_list[_i];
      fullpath = [dir, filename].join(path.sep);
      stat = fs.statSync(fullpath);
      if (stat.isDirectory()) {
        if (!files_only) {
          callback(fullpath, filename, true);
        }
        walkSync(fullpath, callback);
      } else {
        callback(fullpath, filename, false);
      }
    }
    return file_list;
  };

  validateOptionsCallback = function(options, callback) {
    if (typeof options === 'function') {
      return [{}, options];
    } else {
      return [options, callback];
    }
  };

  tryRequire = function(name, callback) {
    var lib;
    if (name === null || name === '') {
      callback(null, {});
      return;
    }
    if (loaded_libs[name] != null) {
      callback(null, loaded_libs[name]);
      return;
    }
    try {
      lib = require(name);
      loaded_libs[name] = lib;
      return callback(null, lib);
    } catch (ex) {
      return localRequire(name, callback);
    }
  };

  tryRequireAll = function(names, callback) {
    var libnames, libs, loader, nextLib;
    if (names.length === 0) {
      callback(null, []);
      return;
    }
    libs = [];
    libnames = names.slice();
    nextLib = libnames.shift();
    loader = function(err, lib) {
      if (err != null) {
        return callback(err, null);
      } else {
        libs.push(lib);
        if (libnames.length === 0) {
          return callback(null, libs);
        } else {
          nextLib = libnames.shift();
          return tryRequire(nextLib, loader);
        }
      }
    };
    return tryRequire(nextLib, loader);
  };

  loaded_libs = {};

  loading_now = {};

  isAlreadyLoaded = function(name, callback) {
    if (loaded_libs[name] != null) {
      callback(null, loaded_libs[name]);
      return true;
    }
    if (loading_now[name] != null) {
      loading_now[name].push(callback);
      return true;
    } else {
      loading_now[name] = [];
      loading_now[name].push(callback);
      return false;
    }
  };

  localRequire = function(name, callback) {
    var child, cmd;
    if (isAlreadyLoaded(name, callback)) {
      return false;
    }
    cmd = "" + process.execPath + " -p -e \"require.resolve('" + name + "')\"";
    child = exec(cmd, function(stdin, stdout, stderr) {
      var cb, err, lib, libpath, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
      libpath = stdout.trim();
      if (libpath === '') {
        err = new Error("Could not load '" + name + "' module. (no local path)");
        _ref1 = loading_now[name];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          cb = _ref1[_i];
          cb(err, null);
        }
      } else {
        try {
          lib = require(libpath);
          loaded_libs[name] = lib;
          _ref2 = loading_now[name];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            cb = _ref2[_j];
            cb(null, lib);
          }
        } catch (ex) {
          _ref3 = loading_now[name];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            cb = _ref3[_k];
            cb(ex, null);
          }
        }
      }
      return delete loading_now[name];
    });
    return true;
  };

  module.exports = {
    pp: pp,
    extend: extend,
    defaults: defaults,
    walk: walk,
    walkSync: walkSync,
    validateOptionsCallback: validateOptionsCallback,
    tryRequire: tryRequire,
    tryRequireAll: tryRequireAll,
    localRequire: localRequire
  };

  extend(module.exports, util);

}).call(this);
