// Generated by CoffeeScript 1.5.0
(function() {
  var api, assemble_files, build_css_package, build_js_package, converter, defaults, do_header, do_minify, filelistForType, fs, outputTargets, path, project_root, uglify, _;

  path = require('path');

  fs = require('fs');

  defaults = require('./defaults');

  _ = require('./util');

  converter = require('./converter');

  project_root = process.cwd();

  uglify = require("uglify-js");

  do_minify = function(output_content, config) {
    var settings;
    if (config.minify) {
      if (uglify != null) {
        _.log("Minify... (" + config.output.target + ")");
        try {
          settings = {
            fromString: true,
            mangle: false
          };
          if (config.sourceMap) {
            settings.outSourceMap = config.output.sourceMapName;
          }
          switch (config.minify) {
            case 1:
            case 'minify':
            case 'min':
              return uglify.minify(output_content, settings);
            case 2:
            case 'mangle':
            case 'munge':
            case 'compress':
              settings.mangle = true;
              return uglify.minify(output_content, settings);
            default:
              return {
                code: output_content,
                map: null
              };
          }
        } catch (ex) {
          _.log("Error in minify, skipping... (" + config.output.target + ")");
          return {
            code: output_content,
            map: null
          };
        }
      } else {
        _.log("Can't minify (install uglify-js) (" + config.output.target + ")");
        return {
          code: output_content,
          map: null
        };
      }
    } else {
      return {
        code: output_content,
        map: null
      };
    }
  };

  do_header = function(output_content, config) {
    if (config.header) {
      return "" + (converter.replaceTokens(config.header, config)) + "\n" + output_content;
    } else {
      return output_content;
    }
  };

  outputTargets = function(info) {
    var config, ext, output, targets;
    targets = [];
    for (output in info) {
      config = info[output];
      ext = path.extname(output);
      if (ext === '.js' || ext === '.css') {
        targets.push(output);
      }
    }
    return targets;
  };

  module.exports = api = {
    buildTargets: function(config, resolvePaths) {
      var target, targets, targetsFP, _i, _len;
      if (resolvePaths == null) {
        resolvePaths = false;
      }
      this.prepConfig(config);
      targets = outputTargets(config);
      if (resolvePaths) {
        targetsFP = [];
        for (_i = 0, _len = targets.length; _i < _len; _i++) {
          target = targets[_i];
          targetsFP.push(path.resolve(target));
        }
        return targetsFP;
      } else {
        return targets;
      }
    },
    buildPackage: function(config, callback) {
      var target;
      _.log("Assembling... (" + config.output.target + ")");
      target = config.type;
      try {
        return assemble_files(target, config, function(err, src_tree) {
          var minified, output_content;
          output_content = target === '.js' ? build_js_package(src_tree, config) : build_css_package(src_tree, config);
          minified = do_minify(output_content, config);
          output_content = minified.code;
          output_content = do_header(output_content, config);
          return callback(null, output_content, minified.map);
        });
      } catch (ex) {
        return callback(ex, null, null);
      }
    },
    prepConfig: function(info, opts) {
      var config, output, src;
      if (opts == null) {
        opts = {};
      }
      for (output in info) {
        config = info[output];
        _.extend(config, opts);
        _.defaults(config, defaults.config);
        config.type = 'meta';
        config.projectRoot = project_root;
        src = config.source;
        if ((src != null) && typeof src === 'string') {
          config.source = {
            target: src,
            path: path.resolve(src),
            dir: "" + (path.resolve(src)) + path.sep
          };
          config.output = {
            target: output,
            name: path.basename(output),
            path: path.resolve(output),
            ext: path.extname(output),
            dir: path.dirname(path.resolve(output)),
            sourceMapName: "" + (path.basename(output)) + ".map",
            sourceMapPath: "" + (path.resolve(output)) + ".map"
          };
          config.type = config.output.ext;
        }
      }
      return info;
    },
    buildTarget: function(config, callback) {
      if (config.type === '.js') {
        return this.buildPackage(config, function(err, output, source_map) {
          if (err != null) {
            throw err;
          }
          if (callback != null) {
            callback(err, output, source_map);
            return;
          }
          if (!fs.existsSync(config.output.dir)) {
            fs.mkdirSync(config.output.dir);
          }
          if ((source_map != null) && config.sourceMap) {
            _.log("SourceMap... (" + config.output.target + ")");
            fs.writeFileSync(config.output.sourceMapPath, source_map, 'utf8');
            output += "\n//@ sourceMappingURL=" + config.output.sourceMapName;
          }
          fs.writeFileSync(config.output.path, output, 'utf8');
          return _.log("Wrote: " + config.output.target + "\n");
        });
      } else if (config.type === '.css') {
        return this.buildPackage(config, function(err, output) {
          if (err != null) {
            throw err;
          }
          if (callback != null) {
            callback(err, output);
            return;
          }
          if (!fs.existsSync(config.output.dir)) {
            fs.mkdirSync(config.output.dir);
          }
          fs.writeFileSync(config.output.path, output, 'utf8');
          return _.log("Wrote: " + config.output.target + "\n");
        });
      }
    },
    build: function(info, opts) {
      var config, output, _results;
      if (opts == null) {
        opts = {};
      }
      _.puts("ASSEMBOT ACTIVATE!");
      this.prepConfig(info, opts);
      _results = [];
      for (output in info) {
        config = info[output];
        _results.push(this.buildTarget(config));
      }
      return _results;
    },
    displayTargetTree: function(info, opts) {
      var config, output, src_dir;
      if (opts == null) {
        opts = {};
      }
      _.puts("ASSEMBOT ACTIVATE!");
      this.prepConfig(info, opts);
      for (output in info) {
        config = info[output];
        _.puts("");
        _.puts(output);
        src_dir = path.dirname(config.source.path);
        _.walkTree(config.source.path, function(file, fullpath) {
          var ext;
          ext = path.extname(file);
          if (converter.validTypeFor(config.type, ext)) {
            return _.puts("  " + (path.relative(src_dir, fullpath)));
          }
        });
      }
      return _.puts("");
    },
    displayModuleTree: function(info, opts) {
      var config, output, src_dir;
      if (opts == null) {
        opts = {};
      }
      _.puts("ASSEMBOT ACTIVATE!");
      this.prepConfig(info, opts);
      for (output in info) {
        config = info[output];
        if (config.type === '.js') {
          _.puts("");
          _.puts("" + config.ident + "  (in " + output + ")");
          src_dir = path.dirname(config.source.path);
          _.walkTree(config.source.path, function(file, fullpath) {
            var ext;
            ext = path.extname(file);
            if (converter.validTypeFor(config.type, ext)) {
              return _.puts("  " + (path.relative(config.source.path, fullpath).replace(ext, '')));
            }
          });
        }
      }
      return _.puts("");
    }
  };

  filelistForType = function(type, path, callback) {
    var filelist;
    filelist = [];
    _.walkTree(path, function(file, fullpath) {
      var ext;
      ext = path.extname(file);
      if (converter.validTypeFor(type, ext)) {
        return filelist.push(fullpath);
      }
    });
    return filelist;
  };

  assemble_files = function(type, info, callback) {
    var build_count, ext, file, fullpath, libpath, output, pkg_list, src_dir, src_path, _i, _len;
    src_path = info.source.path;
    src_dir = "" + src_path + path.sep;
    pkg_list = [];
    output = {};
    _.walkTree(src_path, function(file, fullpath) {
      var ext;
      ext = path.extname(file);
      if (converter.validTypeFor(type, ext)) {
        return pkg_list.push(fullpath);
      }
    });
    build_count = 0;
    for (_i = 0, _len = pkg_list.length; _i < _len; _i++) {
      fullpath = pkg_list[_i];
      file = path.basename(fullpath);
      ext = path.extname(fullpath);
      libpath = fullpath.replace(src_dir, '').replace(ext, '');
      info.current_file = {
        fullpath: fullpath,
        filename: file,
        loadpath: src_path,
        ext: ext,
        path: libpath
      };
      converter.buildSourceFor(type, fullpath, info, function(err, converted_source) {
        if (err != null) {
          throw err;
        }
        build_count += 1;
        output[info.current_file.path] = converted_source;
        if (build_count === pkg_list.length) {
          return callback(null, output);
        }
      });
    }
    return pkg_list;
  };

  build_js_package = function(sources, opts) {
    var autoStart, identifier, index, name, result, source, _ref, _ref1;
    if (opts == null) {
      opts = {};
    }
    identifier = (_ref = opts.ident) != null ? _ref : 'require';
    autoStart = (_ref1 = opts.autoStart) != null ? _ref1 : false;
    result = "(function(/*! Stitched by Assembot !*/) {\n  if (!this." + identifier + ") {\n    var modules = {}, cache = {}, require = function(name, root) {\n      var path = expand(root, name), module = cache[path], fn;\n      if (module) {\n        return module.exports;\n      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {\n        module = {id: path, exports: {}};\n        try {\n          cache[path] = module;\n          fn(module.exports, function(name) {\n            return require(name, dirname(path));\n          }, module);\n          return module.exports;\n        } catch (err) {\n          delete cache[path];\n          throw err;\n        }\n      } else {\n        throw 'module \\'' + name + '\\' not found';\n      }\n    }, expand = function(root, name) {\n      var results = [], parts, part;\n      if (/^\\.\\.?(\\/|$)/.test(name)) {\n        parts = [root, name].join('/').split('/');\n      } else {\n        parts = name.split('/');\n      }\n      for (var i = 0, length = parts.length; i < length; i++) {\n        part = parts[i];\n        if (part == '..') {\n          results.pop();\n        } else if (part != '.' && part != '') {\n          results.push(part);\n        }\n      }\n      return results.join('/');\n    }, dirname = function(path) {\n      return path.split('/').slice(0, -1).join('/');\n    };\n    this." + identifier + " = function(name) {\n      return require(name, '');\n    }\n    this." + identifier + ".define = function(bundle) {\n      for (var key in bundle)\n        modules[key] = bundle[key];\n    };\n    this." + identifier + ".modules= function() {\n      var names= [];\n      for( var name in modules)\n        names.push(name);\n      return names;\n    }\n  }\n  return this." + identifier + ".define;\n}).call(this)({";
    index = 0;
    for (name in sources) {
      source = sources[name];
      result += index++ === 0 ? "" : ", ";
      result += JSON.stringify(name);
      result += ": function(exports, require, module) {" + source + "}";
    }
    result += "});\n";
    if (autoStart) {
      result += "this." + identifier + "('" + autoStart + "');\n";
    }
    return result;
  };

  build_css_package = function(sources, opts) {
    var content, key, results;
    if (opts == null) {
      opts = {};
    }
    results = "";
    for (key in sources) {
      content = sources[key];
      results += "/* " + key + " */\n";
      results += content;
      results += "\n\n";
    }
    return results;
  };

}).call(this);
