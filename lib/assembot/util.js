// Generated by CoffeeScript 1.6.1
(function() {
  var defaults, exec, extend, fs, isAlreadyLoaded, loaded_libs, loading_now, localRequire, path, pp, spawn, tryRequire, tryRequireAll, type, util, validateOptionsCallback, _ref;

  util = require('util');

  fs = require('fs');

  path = require('path');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  pp = function(obj) {
    return util.puts(util.inspect(obj));
  };

  extend = function(obj) {
    var key, source, value, _i, _len, _ref1;
    _ref1 = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      source = _ref1[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          obj[key] = value;
        }
      }
    }
    return obj;
  };

  defaults = function(obj) {
    var key, source, value, _i, _len, _ref1;
    _ref1 = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      source = _ref1[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          if (obj[key] == null) {
            obj[key] = value;
          }
        }
      }
    }
    return obj;
  };

  type = (function() {
    var classToType, elemParser, name, toStr, _i, _len, _ref1;
    toStr = Object.prototype.toString;
    elemParser = /\[object HTML(.*)\]/;
    classToType = {};
    _ref1 = "Boolean Number String Function Array Date RegExp Undefined Null NodeList".split(" ");
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var found, strType;
      strType = toStr.call(obj);
      if (found = classToType[strType]) {
        return found;
      } else if (found = strType.match(elemParser)) {
        return found[1].toLowerCase();
      } else {
        return "object";
      }
    };
  })();

  validateOptionsCallback = function(options, callback) {
    if (typeof options === 'function') {
      return [{}, options];
    } else {
      return [options, callback];
    }
  };

  tryRequire = function(name, callback) {
    var lib;
    if (name === null || name === '') {
      callback(null, {});
      return;
    }
    if (loaded_libs[name] != null) {
      callback(null, loaded_libs[name]);
      return;
    }
    try {
      lib = require(name);
      loaded_libs[name] = lib;
      return callback(null, lib);
    } catch (ex) {
      return localRequire(name, callback);
    }
  };

  tryRequireAll = function(names, callback) {
    var libnames, libs, loader, nextLib;
    if (names.length === 0) {
      callback(null, []);
      return;
    }
    libs = [];
    libnames = names.slice();
    nextLib = libnames.shift();
    loader = function(err, lib) {
      if (err != null) {
        return callback(err, null);
      } else {
        libs.push(lib);
        if (libnames.length === 0) {
          return callback(null, libs);
        } else {
          nextLib = libnames.shift();
          return tryRequire(nextLib, loader);
        }
      }
    };
    return tryRequire(nextLib, loader);
  };

  loaded_libs = {};

  loading_now = {};

  isAlreadyLoaded = function(name, callback) {
    if (loaded_libs[name] != null) {
      callback(null, loaded_libs[name]);
      return true;
    }
    if (loading_now[name] != null) {
      loading_now[name].push(callback);
      return true;
    } else {
      loading_now[name] = [];
      loading_now[name].push(callback);
      return false;
    }
  };

  localRequire = function(name, callback) {
    var child, cmd;
    if (isAlreadyLoaded(name, callback)) {
      return false;
    }
    cmd = "" + process.execPath + " -p -e \"require.resolve('" + name + "')\"";
    child = exec(cmd, function(stdin, stdout, stderr) {
      var cb, err, lib, libpath, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
      libpath = stdout.trim();
      if (libpath === '') {
        err = new Error("Could not load '" + name + "' module. (no local path)");
        _ref1 = loading_now[name];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          cb = _ref1[_i];
          cb(err, null);
        }
      } else {
        try {
          lib = require(libpath);
          loaded_libs[name] = lib;
          _ref2 = loading_now[name];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            cb = _ref2[_j];
            cb(null, lib);
          }
        } catch (ex) {
          _ref3 = loading_now[name];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            cb = _ref3[_k];
            cb(ex, null);
          }
        }
      }
      return delete loading_now[name];
    });
    return true;
  };

  module.exports = {
    pp: pp,
    extend: extend,
    defaults: defaults,
    type: type,
    validateOptionsCallback: validateOptionsCallback,
    tryRequire: tryRequire,
    tryRequireAll: tryRequireAll,
    localRequire: localRequire
  };

  extend(module.exports, util);

}).call(this);
