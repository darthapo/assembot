// Generated by CoffeeScript 1.6.1
(function() {
  var addConvertor, addCssConvertor, addJsConvertor, api, assembot_package, compile_less, compile_stylus, ecss_wrapper, fs, path, project_package, project_root, type_db, validType, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  fs = require('fs');

  _ = require('./util');

  project_root = process.cwd();

  assembot_package = require('../package');

  project_package = (function() {
    try {
      return require("" + project_root + path.sep + "package");
    } catch (ex) {
      return {};
    }
  })();

  type_db = {
    ".js": {
      types: [],
      handlers: {}
    },
    ".css": {
      types: [],
      handlers: {}
    }
  };

  validType = function(target) {
    if (target[0] === '.') {
      return target;
    } else {
      return "." + target;
    }
  };

  module.exports = api = {
    tokenParser: /(\{%\-([ a-zA-Z0-9\._]*)\-%\})/g,
    replaceTokens: function(string, info) {
      if (info.replaceTokens && this.tokenParser.test(string)) {
        return string.replace(this.tokenParser, function(match, token, value, loc, src) {
          var data, first_part, key, part, parts, _i, _len;
          data = info;
          parts = value.split('.');
          first_part = parts.shift().trim();
          switch (first_part) {
            case 'package':
              data = project_package;
              break;
            case 'assembot':
              data = assembot_package;
              break;
            case 'NOW':
              data = new Date();
              break;
            default:
              data = info[first_part];
          }
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            key = part.trim();
            data = data[key];
          }
          return String(data);
        });
      } else {
        return string;
      }
    },
    debug: function() {
      return _.pp(type_db);
    },
    addFor: function(target, type, converter) {
      target = validType(target);
      type = validType(type);
      type_db[target].types.push(type);
      type_db[target].handlers[type] = function(src, opts, callback) {
        var file;
        try {
          return converter(src, opts, callback);
        } catch (ex) {
          file = "" + opts.current_file.path + opts.current_file.ext;
          ex.name = "Processor Error";
          ex.message = "Processor Error for " + file + ": " + ex.message;
          return callback(ex, null, opts);
        }
      };
      return this;
    },
    validTypeFor: function(target, ext) {
      var type;
      target = validType(target);
      type = validType(ext);
      if (type_db[target] != null) {
        return __indexOf.call(type_db[target].types, type) >= 0;
      } else {
        return false;
      }
    },
    buildSourceFor: function(target, fullpath, info, callback) {
      var converter, ext, source;
      target = validType(target);
      ext = path.extname(fullpath);
      source = fs.readFileSync(fullpath, 'utf8');
      converter = type_db[target].handlers[ext];
      converter(this.replaceTokens(String(source), info), info, callback);
      return this;
    }
  };

  addConvertor = function(target, type, modules, handler) {
    var loading, queue;
    if (!_.isArray(modules)) {
      modules = [modules];
    }
    loading = false;
    queue = [];
    return api.addFor(target, type, function(origSrc, origOpts, origCallback) {
      queue.push([origSrc, origOpts, origCallback]);
      if (!loading) {
        loading = true;
        return _.tryRequireAll(modules, function(err, libs) {
          var arglist, converter, _i, _len;
          if (err != null) {
            throw new Error("Module(s) '" + (modules.join("'")) + "' cannot be loaded! " + err);
          }
          converter = handler.apply(handler, libs);
          api.addFor(target, type, converter);
          for (_i = 0, _len = queue.length; _i < _len; _i++) {
            arglist = queue[_i];
            converter.apply(converter, arglist);
          }
          return true;
        });
      }
    });
  };

  addJsConvertor = function(type, modules, handler) {
    var thisType, _i, _len;
    if (_.isArray(type)) {
      for (_i = 0, _len = type.length; _i < _len; _i++) {
        thisType = type[_i];
        addConvertor('js', thisType, modules, handler);
      }
    } else {
      addConvertor('js', type, modules, handler);
    }
    return true;
  };

  addCssConvertor = function(type, modules, handler) {
    return addConvertor('css', type, modules, handler);
  };

  addJsConvertor('.js', [], function() {
    return function(source, opts, converted) {
      return converted(null, source, opts);
    };
  });

  addJsConvertor('.html', [], function() {
    return function(source, opts, converted) {
      return converted(null, "module.exports=" + (JSON.stringify(source)) + ";", opts);
    };
  });

  addJsConvertor('.json', [], function() {
    return function(source, opts, converted) {
      var data;
      data = JSON.parse(source);
      return converted(null, "module.exports=" + (JSON.stringify(data)) + ";", opts);
    };
  });

  addJsConvertor(['.coffee', '.litcoffee'], 'coffee-script', function(coffee) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.coffee || {}, {
        bare: true
      });
      options.literate = opts.current_file.ext === '.litcoffee' || false;
      output = coffee.compile(source, options);
      return converted(null, output, opts);
    };
  });

  addJsConvertor('.eco', 'eco', function(eco) {
    return function(source, opts, converted) {
      var output;
      output = eco.precompile(source);
      return converted(null, "module.exports= " + output + ";", opts);
    };
  });

  addJsConvertor(['.mustache'], ['coffee-templates'], function(coffee_templates) {
    return function(source, opts, converted) {
      var output;
      output = coffee_templates.compile(source);
      return converted(null, "module.exports= " + output + ";", opts);
    };
  });

  addJsConvertor('.ejs', 'ejs', function(ejs) {
    return function(source, opts, converted) {
      var output;
      output = ejs.compile(source, {
        client: true,
        compileDebug: false
      });
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addJsConvertor('.dot', 'doT', function(dot) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.dot || opts.doT || {}, {});
      output = dot.compile(source, options);
      return converted(null, "module.exports= " + (output.toString()), opts);
    };
  });

  addJsConvertor(['.md', 'markdown'], 'marked', function(marked) {
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.marked || {}, {
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: false,
        smartLists: true
      });
      output = marked(source, options);
      return converted(null, "module.exports=" + (JSON.stringify(output)) + ";", opts);
    };
  });

  addJsConvertor('.settee', ['./settee'], function(settee) {
    return function(source, opts, converted) {
      var output;
      output = "if(!this.settee) settee= require('settee');\nmodule.exports=settee(" + (JSON.stringify(settee.settee.parse(source))) + ");";
      return converted(null, output, opts);
    };
  });

  addJsConvertor('.jade', 'jade', function(jade) {
    _.puts("Jade requires a runtime, be sure it's included in your page.");
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.jade || {}, {
        client: true,
        compileDebug: false
      });
      output = jade.compile(source, options);
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  addJsConvertor('.hogan', 'hogan.js', function(hogan) {
    _.puts("Hogan requires a runtime, be sure it's included in your page.");
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.hogan || {}, {
        asString: 1
      });
      output = hogan.compile(source, options);
      return converted(null, "module.exports= new Hogan.Template(" + (output.toString()) + ");", opts);
    };
  });

  addJsConvertor('.handlebars', 'handlebars', function(handlebars) {
    _.puts("Handlebars requires a runtime, be sure it's included in your page.");
    return function(source, opts, converted) {
      var options, output;
      options = _.defaults({}, opts.handlebars || {}, {
        simple: false,
        commonjs: true
      });
      output = handlebars.precompile(source, options);
      return converted(null, "module.exports= " + (output.toString()) + ";", opts);
    };
  });

  compile_less = function(less, source, callback) {
    return less.render(source, callback);
  };

  compile_stylus = function(stylus, nib, source, opts, callback) {
    var options;
    options = _.defaults({}, opts.stylus || {}, {
      filename: opts.current_file.filename || 'generated.css',
      paths: opts.load_paths
    });
    return stylus(source).set('filename', opts.current_file.filename || 'generated.css').set('paths', opts.load_paths).set(options).use(nib()).render(callback);
  };

  addCssConvertor('.css', [], function() {
    return function(source, opts, converted) {
      return converted(null, source, opts);
    };
  });

  addCssConvertor('.less', 'less', function(less) {
    return function(source, opts, converted) {
      return compile_less(less, source, function(err, css) {
        if (err != null) {
          converted(err, null, opts);
        }
        return converted(null, css, opts);
      });
    };
  });

  addCssConvertor('.styl', ['stylus', 'nib'], function(stylus, nib) {
    var load_paths;
    load_paths = [process.cwd(), path.dirname(__dirname)];
    return function(source, opts, converted) {
      opts.load_paths = load_paths;
      return compile_stylus(stylus, nib, source, opts, function(err, css) {
        if (err != null) {
          return converted(err, null, opts);
        } else {
          return converted(null, css, opts);
        }
      });
    };
  });

  ecss_wrapper = function(css) {
    return "var node = null, css = " + (JSON.stringify(css)) + ";\nmodule.exports= {\n  content: css,\n  isActive: function(){ return node != null; },\n  activate: function(to){\n    if(node != null) return; // Already added to DOM!\n    to= to || document.getElementsByTagName('HEAD')[0] || document.body || document; // In the HEAD or BODY tags\n    node= document.createElement('style');\n    node.innerHTML= css;\n    to.appendChild(node);\n    return this;\n  },\n  deactivate: function() {\n    if(node != null) {\n      node.parentNode.removeChild(node);\n      node = null;\n    }\n    return this;\n  }\n};";
  };

  addJsConvertor('.ecss', [], function() {
    return function(source, opts, converted) {
      return converted(null, ecss_wrapper(source), opts);
    };
  });

  addJsConvertor('.eless', 'less', function(less) {
    return function(source, opts, converted) {
      return compile_less(less, source, function(err, css) {
        if (err != null) {
          converted(err, null, opts);
        }
        return converted(null, ecss_wrapper(css), opts);
      });
    };
  });

  addJsConvertor('.estyl', ['stylus', 'nib'], function(stylus, nib) {
    var load_paths;
    load_paths = [process.cwd(), path.dirname(__dirname)];
    return function(source, opts, converted) {
      opts.load_paths = load_paths;
      return compile_stylus(stylus, nib, source, opts, function(err, css) {
        if (err != null) {
          return converted(err, null, opts);
        } else {
          return converted(null, ecss_wrapper(css), opts);
        }
      });
    };
  });

}).call(this);
